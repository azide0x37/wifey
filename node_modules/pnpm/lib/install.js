var Promise = require('./promise');
var debug = require('debug')('pnpm:install');
var npa = require('npm-package-arg');
var getUuid = require('node-uuid');
var fs = require('mz/fs');

var join = require('path').join;
var dirname = require('path').dirname;
var basename = require('path').basename;
var abspath = require('path').resolve;

var fetch = require('./fetch');
var resolve = require('./resolve');

var mkdirp = require('./fs/mkdirp');
var symlink = require('./fs/force_symlink');
var obliterate = require('./fs/obliterate');
var requireJson = require('./fs/require_json');
var relSymlink = require('./fs/rel_symlink');

var linkBins = require('./install/link_bins');
var linkBundledDeps = require('./install/link_bundled_deps');
var isAvailable = require('./install/is_available');
var postInstall = require('./install/post_install');

/*
 * Installs a package.
 *
 *     install(ctx, 'rimraf@2', './node_modules')
 *
 * Parameters:
 *
 * - `ctx` (Object) - the context.
 *   - `root` (String) - root path of the package.
 *   - `tmp` (String) - temp dir
 *   - `log` (Function) - logger
 *
 * What it does:
 *
 * - resolve() - resolve from registry.npmjs.org
 * - fetch() - download tarball into node_modules/.tmp/{uuid}
 * - recurse into its dependencies
 * - run postinstall hooks
 * - move .tmp/{uuid} into node_modules/{name}@{version}
 * - symlink node_modules/{name}
 * - symlink bins
 */

module.exports = function install(ctx, pkgSpec, modules, options) {
  debug('installing ' + pkgSpec);
  if (!ctx.builds) ctx.builds = {};
  if (!ctx.fetches) ctx.fetches = {};
  if (!ctx.ignoreScripts) ctx.ignoreScripts = options && options.ignoreScripts;

  var pkg = {
    // Preliminary spec data
    // => { raw, name, scope, type, spec, rawSpec }
    spec: npa(pkgSpec),

    // Dependency path to the current package. Not actually needed anmyore
    // outside getting its length
    // => ['babel-core@6.4.5', 'babylon@6.4.5', 'babel-runtime@5.8.35']
    keypath: options && options.keypath || [],

    // Full name of package as it should be put in the store. Aim to make
    // this as friendly as possible as this will appear in stack traces.
    // => 'lodash@4.0.0'
    // => '@rstacruz!tap-spec@4.1.1'
    // => 'rstacruz!pnpm@0a1b382da'
    // => 'foobar@9a3b283ac'
    fullname: undefined,

    // Distribution data from resolve() => { shasum, tarball }
    dist: undefined,

    // package.json data as retrieved from resolve() => { name, version, ... }
    data: undefined
  };

  var paths = {
    // Module storage => './node_modules'
    modules: modules,

    // Temporary destination while building
    tmp: join(ctx.store, '..', '.tmp', getUuid()),

    // Final destination => store + '/lodash@4.0.0'
    target: undefined
  };

  var log = ctx.log(pkg.spec); // function

  // it might be a bundleDependency, in which case, don't bother
  return isAvailable(pkg.spec, modules).then(function (_) {
    return _ ? saveCachedResolution().then(function (data) {
      return log('package.json', data);
    }) : resolve(pkg.spec, log).then(saveResolution).then(function (_) {
      return log('resolved', pkg);
    }).then(function (_) {
      return buildToStoreCached(ctx, paths, pkg, log);
    }).then(function (_) {
      return mkdirp(paths.modules);
    }).then(function (_) {
      return symlinkToModules(join(paths.target, '_'), paths.modules);
    }).then(function (_) {
      return log('package.json', requireJson(join(paths.target, '_', 'package.json')));
    });
  })
  // done
  .then(function (_) {
    if (!ctx.installs) ctx.installs = {};
    ctx.installs[pkg.fullname] = pkg;
  }).then(function (_) {
    return log('done');
  }).then(function (_) {
    return pkg;
  }).catch(function (err) {
    log('error', err);
    throw err;
  });

  // set metadata as fetched from resolve()
  function saveResolution(res) {
    pkg.name = res.name;
    pkg.fullname = res.fullname;
    pkg.version = res.version;
    pkg.dist = res.dist;
    paths.target = join(ctx.store, res.fullname);
  }

  function saveCachedResolution() {
    var target = join(modules, pkg.spec.name);
    return fs.lstat(target).then(function (stat) {
      if (stat.isSymbolicLink()) {
        return fs.readlink(target).then(function (path) {
          return save(abspath(path, target));
        });
      } else {
        return save(target);
      }
    });

    function save(fullpath) {
      var data = requireJson(join(fullpath, 'package.json'));
      pkg.name = data.name;
      pkg.fullname = basename(fullpath);
      pkg.version = data.version;
      pkg.data = data;
      paths.target = fullpath;
    }
  }
};

/*
 * Builds to `.store/lodash@4.0.0` (paths.target)
 * If an ongoing build is already working, use it. Also, if that ongoing build
 * is part of the dependency chain (ie, it's a circular dependency), use its stub
 */

function buildToStoreCached(ctx, paths, pkg, log) {
  // If a package is requested for a second time (usually when many packages depend
  // on the same thing), only resolve until it's fetched (not built).
  if (ctx.builds[pkg.fullname]) return ctx.fetches[pkg.fullname];

  return make(paths.target, ctx.builds[pkg.fullname], function (_) {
    return memoize(ctx.builds, pkg.fullname, function (_) {
      return Promise.resolve().then(function (_) {
        return memoize(ctx.fetches, pkg.fullname, function (_) {
          return fetchToStore(ctx, paths, pkg, log);
        });
      }).then(function (_) {
        return buildInStore(ctx, paths, pkg, log);
      });
    });
  });
}

/*
 * Builds to `.store/lodash@4.0.0` (paths.target)
 * Fetches from npm, recurses to dependencies, runs lifecycle scripts, etc
 */

function fetchToStore(ctx, paths, pkg, log) {
  return Promise.resolve()
  // symlink .tmp/0a1b2c3d -> .store/lodash@4.0.0
  // so that when any other module requires it, it's available even
  // if it's partially built
  .then(function (_) {
    return mkdirp(dirname(paths.target));
  }).then(function (_) {
    return symlink(paths.tmp, paths.target);
  })

  // download and untar
  .then(function (_) {
    return log('download-queued');
  }).then(function (_) {
    return mkdirp(ctx.store);
  }).then(function (_) {
    return mkdirp(join(paths.tmp, '_'));
  }).then(function (_) {
    return fs.writeFile(join(paths.tmp, '.pnpm_inprogress'), '', 'utf-8');
  }).then(function (_) {
    return fetch(join(paths.tmp, '_'), pkg.dist.tarball, pkg.dist.shasum, log);
  });

  // TODO: this is the point it becomes partially useable.
  // ie, it can now be symlinked into .store/foo@1.0.0.
  // it is only here that it should be available for ciruclar dependencies.
}

function buildInStore(ctx, paths, pkg, log) {
  var installAll = require('./install_multiple');
  var fulldata;

  return Promise.resolve().then(function (_) {
    fulldata = requireJson(abspath(join(paths.tmp, '_', 'package.json')));
  }).then(function (_) {
    return log('package.json', fulldata);
  })

  // link node_modules/.bin
  .then(function (_) {
    return linkBins(paths.modules, join(paths.tmp, '_'), join(paths.target, '_'));
  }).then(function (_) {
    return linkBundledDeps(join(paths.tmp, '_'));
  })

  // recurse down to dependencies
  .then(function (_) {
    return log('dependencies');
  }).then(function (_) {
    return installAll(ctx, fulldata.dependencies, join(paths.tmp, '_', 'node_modules'), { keypath: pkg.keypath.concat([pkg.fullname]) });
  })

  // symlink itself; . -> node_modules/lodash@4.0.0
  // this way it can require itself
  .then(function (_) {
    return symlinkSelf(paths.tmp, fulldata, pkg.keypath.length);
  })

  // postinstall hooks
  .then(function (_) {
    return !ctx.ignoreScripts && postInstall(paths.tmp, fulldata, installLogger(log, pkg));
  })

  // move to .store/lodash@4.0.0; remove the stub done earlier
  .then(function (_) {
    return fs.unlink(join(paths.tmp, '.pnpm_inprogress'));
  })
  // we need to make sure that symlinkToModules for another project dependent
  // on this package will not get called inbetween `unlink` and `rename`
  // the easiest way to achieve this is to make them synchronous
  .then(function (_) {
    fs.unlinkSync(paths.target);
    fs.renameSync(paths.tmp, paths.target);
  });
}

function installLogger(log, pkg) {
  return function (stream, line) {
    require('debug')('pnpm:post_install')('%s %s', pkg.fullname, line);
    log(stream, { name: pkg.fullname, line: line });
  };
}

/*
 * Symlink a package into its own node_modules. this way, babel-runtime@5 can
 * require('babel-runtime') within itself.
 */

function symlinkSelf(target, pkg, depth) {
  debug('symlinkSelf %s', pkg.name);
  if (depth === 0) {
    return Promise.resolve();
  } else {
    return mkdirp(join(target, 'node_modules')).then(function (_) {
      return symlink(join('..', '_'), join(target, 'node_modules', pkg.name));
    });
  }
}

/*
 * Perform the final symlinking of ./.store/x@1.0.0 -> ./x.
 *
 *     target = '/node_modules/.store/lodash@4.0.0'
 *     modules = './node_modules'
 *     symlinkToModules(fullname, modules)
 */

function symlinkToModules(target, modules) {
  // TODO: uncomment to make things fail
  var pkgData = requireJson(join(target, 'package.json'));
  if (!pkgData.name) {
    throw new Error('Invalid package.json for ' + target);
  }

  // lodash -> .store/lodash@4.0.0
  // .store/foo@1.0.0/node_modules/lodash -> ../../../.store/lodash@4.0.0
  // .tmp/01234567890/node_modules/lodash -> ../../../.store/lodash@4.0.0
  var out = join(modules, pkgData.name);
  return mkdirp(dirname(out)).then(function (_) {
    return relSymlink(target, out);
  });
}

/*
 * If `path` doesn't exist, run `fn()`.
 * If it exists and is not in progress, don't do anything.
 * If it's in progress, check if we're working on it. If we're not,
 * obliterate it and run `fn()`.
 */

function make(path, isWorking, fn) {
  return fs.stat(path).then(function (_) {
    return fs.stat(join(path, '.pnpm_inprogress')).then(function (_) {
      if (!isWorking) return obliterate(path).then(fn);
    }).catch(function (err) {
      if (err.code !== 'ENOENT') throw err;
    });
  }).catch(function (err) {
    if (err.code !== 'ENOENT') throw err;
    return fn();
  });
}

/*
 * Save promises for later
 */

function memoize(locks, key, fn) {
  if (locks && locks[key]) return locks[key];
  locks[key] = fn();
  return locks[key];
}
//# sourceMappingURL=data:application/json;base64,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cm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3BucG06aW5zdGFsbCcpXG52YXIgbnBhID0gcmVxdWlyZSgnbnBtLXBhY2thZ2UtYXJnJylcbnZhciBnZXRVdWlkID0gcmVxdWlyZSgnbm9kZS11dWlkJylcbnZhciBmcyA9IHJlcXVpcmUoJ216L2ZzJylcblxudmFyIGpvaW4gPSByZXF1aXJlKCdwYXRoJykuam9pblxudmFyIGRpcm5hbWUgPSByZXF1aXJlKCdwYXRoJykuZGlybmFtZVxudmFyIGJhc2VuYW1lID0gcmVxdWlyZSgncGF0aCcpLmJhc2VuYW1lXG52YXIgYWJzcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKS5yZXNvbHZlXG5cbnZhciBmZXRjaCA9IHJlcXVpcmUoJy4vZmV0Y2gnKVxudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKVxuXG52YXIgbWtkaXJwID0gcmVxdWlyZSgnLi9mcy9ta2RpcnAnKVxudmFyIHN5bWxpbmsgPSByZXF1aXJlKCcuL2ZzL2ZvcmNlX3N5bWxpbmsnKVxudmFyIG9ibGl0ZXJhdGUgPSByZXF1aXJlKCcuL2ZzL29ibGl0ZXJhdGUnKVxudmFyIHJlcXVpcmVKc29uID0gcmVxdWlyZSgnLi9mcy9yZXF1aXJlX2pzb24nKVxudmFyIHJlbFN5bWxpbmsgPSByZXF1aXJlKCcuL2ZzL3JlbF9zeW1saW5rJylcblxudmFyIGxpbmtCaW5zID0gcmVxdWlyZSgnLi9pbnN0YWxsL2xpbmtfYmlucycpXG52YXIgbGlua0J1bmRsZWREZXBzID0gcmVxdWlyZSgnLi9pbnN0YWxsL2xpbmtfYnVuZGxlZF9kZXBzJylcbnZhciBpc0F2YWlsYWJsZSA9IHJlcXVpcmUoJy4vaW5zdGFsbC9pc19hdmFpbGFibGUnKVxudmFyIHBvc3RJbnN0YWxsID0gcmVxdWlyZSgnLi9pbnN0YWxsL3Bvc3RfaW5zdGFsbCcpXG5cbi8qXG4gKiBJbnN0YWxscyBhIHBhY2thZ2UuXG4gKlxuICogICAgIGluc3RhbGwoY3R4LCAncmltcmFmQDInLCAnLi9ub2RlX21vZHVsZXMnKVxuICpcbiAqIFBhcmFtZXRlcnM6XG4gKlxuICogLSBgY3R4YCAoT2JqZWN0KSAtIHRoZSBjb250ZXh0LlxuICogICAtIGByb290YCAoU3RyaW5nKSAtIHJvb3QgcGF0aCBvZiB0aGUgcGFja2FnZS5cbiAqICAgLSBgdG1wYCAoU3RyaW5nKSAtIHRlbXAgZGlyXG4gKiAgIC0gYGxvZ2AgKEZ1bmN0aW9uKSAtIGxvZ2dlclxuICpcbiAqIFdoYXQgaXQgZG9lczpcbiAqXG4gKiAtIHJlc29sdmUoKSAtIHJlc29sdmUgZnJvbSByZWdpc3RyeS5ucG1qcy5vcmdcbiAqIC0gZmV0Y2goKSAtIGRvd25sb2FkIHRhcmJhbGwgaW50byBub2RlX21vZHVsZXMvLnRtcC97dXVpZH1cbiAqIC0gcmVjdXJzZSBpbnRvIGl0cyBkZXBlbmRlbmNpZXNcbiAqIC0gcnVuIHBvc3RpbnN0YWxsIGhvb2tzXG4gKiAtIG1vdmUgLnRtcC97dXVpZH0gaW50byBub2RlX21vZHVsZXMve25hbWV9QHt2ZXJzaW9ufVxuICogLSBzeW1saW5rIG5vZGVfbW9kdWxlcy97bmFtZX1cbiAqIC0gc3ltbGluayBiaW5zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnN0YWxsIChjdHgsIHBrZ1NwZWMsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2luc3RhbGxpbmcgJyArIHBrZ1NwZWMpXG4gIGlmICghY3R4LmJ1aWxkcykgY3R4LmJ1aWxkcyA9IHt9XG4gIGlmICghY3R4LmZldGNoZXMpIGN0eC5mZXRjaGVzID0ge31cbiAgaWYgKCFjdHguaWdub3JlU2NyaXB0cykgY3R4Lmlnbm9yZVNjcmlwdHMgPSBvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlU2NyaXB0c1xuXG4gIHZhciBwa2cgPSB7XG4gICAgLy8gUHJlbGltaW5hcnkgc3BlYyBkYXRhXG4gICAgLy8gPT4geyByYXcsIG5hbWUsIHNjb3BlLCB0eXBlLCBzcGVjLCByYXdTcGVjIH1cbiAgICBzcGVjOiBucGEocGtnU3BlYyksXG5cbiAgICAvLyBEZXBlbmRlbmN5IHBhdGggdG8gdGhlIGN1cnJlbnQgcGFja2FnZS4gTm90IGFjdHVhbGx5IG5lZWRlZCBhbm15b3JlXG4gICAgLy8gb3V0c2lkZSBnZXR0aW5nIGl0cyBsZW5ndGhcbiAgICAvLyA9PiBbJ2JhYmVsLWNvcmVANi40LjUnLCAnYmFieWxvbkA2LjQuNScsICdiYWJlbC1ydW50aW1lQDUuOC4zNSddXG4gICAga2V5cGF0aDogKG9wdGlvbnMgJiYgb3B0aW9ucy5rZXlwYXRoIHx8IFtdKSxcblxuICAgIC8vIEZ1bGwgbmFtZSBvZiBwYWNrYWdlIGFzIGl0IHNob3VsZCBiZSBwdXQgaW4gdGhlIHN0b3JlLiBBaW0gdG8gbWFrZVxuICAgIC8vIHRoaXMgYXMgZnJpZW5kbHkgYXMgcG9zc2libGUgYXMgdGhpcyB3aWxsIGFwcGVhciBpbiBzdGFjayB0cmFjZXMuXG4gICAgLy8gPT4gJ2xvZGFzaEA0LjAuMCdcbiAgICAvLyA9PiAnQHJzdGFjcnV6IXRhcC1zcGVjQDQuMS4xJ1xuICAgIC8vID0+ICdyc3RhY3J1eiFwbnBtQDBhMWIzODJkYSdcbiAgICAvLyA9PiAnZm9vYmFyQDlhM2IyODNhYydcbiAgICBmdWxsbmFtZTogdW5kZWZpbmVkLFxuXG4gICAgLy8gRGlzdHJpYnV0aW9uIGRhdGEgZnJvbSByZXNvbHZlKCkgPT4geyBzaGFzdW0sIHRhcmJhbGwgfVxuICAgIGRpc3Q6IHVuZGVmaW5lZCxcblxuICAgIC8vIHBhY2thZ2UuanNvbiBkYXRhIGFzIHJldHJpZXZlZCBmcm9tIHJlc29sdmUoKSA9PiB7IG5hbWUsIHZlcnNpb24sIC4uLiB9XG4gICAgZGF0YTogdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcGF0aHMgPSB7XG4gICAgLy8gTW9kdWxlIHN0b3JhZ2UgPT4gJy4vbm9kZV9tb2R1bGVzJ1xuICAgIG1vZHVsZXM6IG1vZHVsZXMsXG5cbiAgICAvLyBUZW1wb3JhcnkgZGVzdGluYXRpb24gd2hpbGUgYnVpbGRpbmdcbiAgICB0bXA6IGpvaW4oY3R4LnN0b3JlLCAnLi4nLCAnLnRtcCcsIGdldFV1aWQoKSksXG5cbiAgICAvLyBGaW5hbCBkZXN0aW5hdGlvbiA9PiBzdG9yZSArICcvbG9kYXNoQDQuMC4wJ1xuICAgIHRhcmdldDogdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgbG9nID0gY3R4LmxvZyhwa2cuc3BlYykgLy8gZnVuY3Rpb25cblxuICAvLyBpdCBtaWdodCBiZSBhIGJ1bmRsZURlcGVuZGVuY3ksIGluIHdoaWNoIGNhc2UsIGRvbid0IGJvdGhlclxuICByZXR1cm4gaXNBdmFpbGFibGUocGtnLnNwZWMsIG1vZHVsZXMpXG4gICAgLnRoZW4oXyA9PiBfXG4gICAgICA/IHNhdmVDYWNoZWRSZXNvbHV0aW9uKClcbiAgICAgICAgLnRoZW4oZGF0YSA9PiBsb2coJ3BhY2thZ2UuanNvbicsIGRhdGEpKVxuICAgICAgOiByZXNvbHZlKHBrZy5zcGVjLCBsb2cpXG4gICAgICAgIC50aGVuKHNhdmVSZXNvbHV0aW9uKVxuICAgICAgICAudGhlbihfID0+IGxvZygncmVzb2x2ZWQnLCBwa2cpKVxuICAgICAgICAudGhlbihfID0+IGJ1aWxkVG9TdG9yZUNhY2hlZChjdHgsIHBhdGhzLCBwa2csIGxvZykpXG4gICAgICAgIC50aGVuKF8gPT4gbWtkaXJwKHBhdGhzLm1vZHVsZXMpKVxuICAgICAgICAudGhlbihfID0+IHN5bWxpbmtUb01vZHVsZXMoam9pbihwYXRocy50YXJnZXQsICdfJyksIHBhdGhzLm1vZHVsZXMpKVxuICAgICAgICAudGhlbihfID0+IGxvZygncGFja2FnZS5qc29uJywgcmVxdWlyZUpzb24oam9pbihwYXRocy50YXJnZXQsICdfJywgJ3BhY2thZ2UuanNvbicpKSkpKVxuICAgIC8vIGRvbmVcbiAgICAudGhlbihfID0+IHtcbiAgICAgIGlmICghY3R4Lmluc3RhbGxzKSBjdHguaW5zdGFsbHMgPSB7fVxuICAgICAgY3R4Lmluc3RhbGxzW3BrZy5mdWxsbmFtZV0gPSBwa2dcbiAgICB9KVxuICAgIC50aGVuKF8gPT4gbG9nKCdkb25lJykpXG4gICAgLnRoZW4oXyA9PiBwa2cpXG4gICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICBsb2coJ2Vycm9yJywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcblxuICAvLyBzZXQgbWV0YWRhdGEgYXMgZmV0Y2hlZCBmcm9tIHJlc29sdmUoKVxuICBmdW5jdGlvbiBzYXZlUmVzb2x1dGlvbiAocmVzKSB7XG4gICAgcGtnLm5hbWUgPSByZXMubmFtZVxuICAgIHBrZy5mdWxsbmFtZSA9IHJlcy5mdWxsbmFtZVxuICAgIHBrZy52ZXJzaW9uID0gcmVzLnZlcnNpb25cbiAgICBwa2cuZGlzdCA9IHJlcy5kaXN0XG4gICAgcGF0aHMudGFyZ2V0ID0gam9pbihjdHguc3RvcmUsIHJlcy5mdWxsbmFtZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhdmVDYWNoZWRSZXNvbHV0aW9uICgpIHtcbiAgICB2YXIgdGFyZ2V0ID0gam9pbihtb2R1bGVzLCBwa2cuc3BlYy5uYW1lKVxuICAgIHJldHVybiBmcy5sc3RhdCh0YXJnZXQpXG4gICAgICAudGhlbihzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgIHJldHVybiBmcy5yZWFkbGluayh0YXJnZXQpXG4gICAgICAgICAgICAudGhlbihwYXRoID0+IHNhdmUoYWJzcGF0aChwYXRoLCB0YXJnZXQpKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2F2ZSh0YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICBmdW5jdGlvbiBzYXZlIChmdWxscGF0aCkge1xuICAgICAgdmFyIGRhdGEgPSByZXF1aXJlSnNvbihqb2luKGZ1bGxwYXRoLCAncGFja2FnZS5qc29uJykpXG4gICAgICBwa2cubmFtZSA9IGRhdGEubmFtZVxuICAgICAgcGtnLmZ1bGxuYW1lID0gYmFzZW5hbWUoZnVsbHBhdGgpXG4gICAgICBwa2cudmVyc2lvbiA9IGRhdGEudmVyc2lvblxuICAgICAgcGtnLmRhdGEgPSBkYXRhXG4gICAgICBwYXRocy50YXJnZXQgPSBmdWxscGF0aFxuICAgIH1cbiAgfVxufVxuXG4vKlxuICogQnVpbGRzIHRvIGAuc3RvcmUvbG9kYXNoQDQuMC4wYCAocGF0aHMudGFyZ2V0KVxuICogSWYgYW4gb25nb2luZyBidWlsZCBpcyBhbHJlYWR5IHdvcmtpbmcsIHVzZSBpdC4gQWxzbywgaWYgdGhhdCBvbmdvaW5nIGJ1aWxkXG4gKiBpcyBwYXJ0IG9mIHRoZSBkZXBlbmRlbmN5IGNoYWluIChpZSwgaXQncyBhIGNpcmN1bGFyIGRlcGVuZGVuY3kpLCB1c2UgaXRzIHN0dWJcbiAqL1xuXG5mdW5jdGlvbiBidWlsZFRvU3RvcmVDYWNoZWQgKGN0eCwgcGF0aHMsIHBrZywgbG9nKSB7XG4gIC8vIElmIGEgcGFja2FnZSBpcyByZXF1ZXN0ZWQgZm9yIGEgc2Vjb25kIHRpbWUgKHVzdWFsbHkgd2hlbiBtYW55IHBhY2thZ2VzIGRlcGVuZFxuICAvLyBvbiB0aGUgc2FtZSB0aGluZyksIG9ubHkgcmVzb2x2ZSB1bnRpbCBpdCdzIGZldGNoZWQgKG5vdCBidWlsdCkuXG4gIGlmIChjdHguYnVpbGRzW3BrZy5mdWxsbmFtZV0pIHJldHVybiBjdHguZmV0Y2hlc1twa2cuZnVsbG5hbWVdXG5cbiAgcmV0dXJuIG1ha2UocGF0aHMudGFyZ2V0LCBjdHguYnVpbGRzW3BrZy5mdWxsbmFtZV0sIF8gPT5cbiAgICBtZW1vaXplKGN0eC5idWlsZHMsIHBrZy5mdWxsbmFtZSwgXyA9PlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4oXyA9PiBtZW1vaXplKGN0eC5mZXRjaGVzLCBwa2cuZnVsbG5hbWUsIF8gPT5cbiAgICAgICAgICBmZXRjaFRvU3RvcmUoY3R4LCBwYXRocywgcGtnLCBsb2cpKSlcbiAgICAgICAgLnRoZW4oXyA9PiBidWlsZEluU3RvcmUoY3R4LCBwYXRocywgcGtnLCBsb2cpKVxuICAgICkpXG59XG5cbi8qXG4gKiBCdWlsZHMgdG8gYC5zdG9yZS9sb2Rhc2hANC4wLjBgIChwYXRocy50YXJnZXQpXG4gKiBGZXRjaGVzIGZyb20gbnBtLCByZWN1cnNlcyB0byBkZXBlbmRlbmNpZXMsIHJ1bnMgbGlmZWN5Y2xlIHNjcmlwdHMsIGV0Y1xuICovXG5cbmZ1bmN0aW9uIGZldGNoVG9TdG9yZSAoY3R4LCBwYXRocywgcGtnLCBsb2cpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgLy8gc3ltbGluayAudG1wLzBhMWIyYzNkIC0+IC5zdG9yZS9sb2Rhc2hANC4wLjBcbiAgICAvLyBzbyB0aGF0IHdoZW4gYW55IG90aGVyIG1vZHVsZSByZXF1aXJlcyBpdCwgaXQncyBhdmFpbGFibGUgZXZlblxuICAgIC8vIGlmIGl0J3MgcGFydGlhbGx5IGJ1aWx0XG4gICAgLnRoZW4oXyA9PiBta2RpcnAoZGlybmFtZShwYXRocy50YXJnZXQpKSlcbiAgICAudGhlbihfID0+IHN5bWxpbmsocGF0aHMudG1wLCBwYXRocy50YXJnZXQpKVxuXG4gICAgLy8gZG93bmxvYWQgYW5kIHVudGFyXG4gICAgLnRoZW4oXyA9PiBsb2coJ2Rvd25sb2FkLXF1ZXVlZCcpKVxuICAgIC50aGVuKF8gPT4gbWtkaXJwKGN0eC5zdG9yZSkpXG4gICAgLnRoZW4oXyA9PiBta2RpcnAoam9pbihwYXRocy50bXAsICdfJykpKVxuICAgIC50aGVuKF8gPT4gZnMud3JpdGVGaWxlKGpvaW4ocGF0aHMudG1wLCAnLnBucG1faW5wcm9ncmVzcycpLCAnJywgJ3V0Zi04JykpXG4gICAgLnRoZW4oXyA9PiBmZXRjaChqb2luKHBhdGhzLnRtcCwgJ18nKSwgcGtnLmRpc3QudGFyYmFsbCwgcGtnLmRpc3Quc2hhc3VtLCBsb2cpKVxuXG4gICAgLy8gVE9ETzogdGhpcyBpcyB0aGUgcG9pbnQgaXQgYmVjb21lcyBwYXJ0aWFsbHkgdXNlYWJsZS5cbiAgICAvLyBpZSwgaXQgY2FuIG5vdyBiZSBzeW1saW5rZWQgaW50byAuc3RvcmUvZm9vQDEuMC4wLlxuICAgIC8vIGl0IGlzIG9ubHkgaGVyZSB0aGF0IGl0IHNob3VsZCBiZSBhdmFpbGFibGUgZm9yIGNpcnVjbGFyIGRlcGVuZGVuY2llcy5cbn1cblxuZnVuY3Rpb24gYnVpbGRJblN0b3JlIChjdHgsIHBhdGhzLCBwa2csIGxvZykge1xuICB2YXIgaW5zdGFsbEFsbCA9IHJlcXVpcmUoJy4vaW5zdGFsbF9tdWx0aXBsZScpXG4gIHZhciBmdWxsZGF0YVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKF8gPT4geyBmdWxsZGF0YSA9IHJlcXVpcmVKc29uKGFic3BhdGgoam9pbihwYXRocy50bXAsICdfJywgJ3BhY2thZ2UuanNvbicpKSkgfSlcbiAgICAudGhlbihfID0+IGxvZygncGFja2FnZS5qc29uJywgZnVsbGRhdGEpKVxuXG4gICAgLy8gbGluayBub2RlX21vZHVsZXMvLmJpblxuICAgIC50aGVuKF8gPT4gbGlua0JpbnMocGF0aHMubW9kdWxlcywgam9pbihwYXRocy50bXAsICdfJyksIGpvaW4ocGF0aHMudGFyZ2V0LCAnXycpKSlcbiAgICAudGhlbihfID0+IGxpbmtCdW5kbGVkRGVwcyhqb2luKHBhdGhzLnRtcCwgJ18nKSkpXG5cbiAgICAvLyByZWN1cnNlIGRvd24gdG8gZGVwZW5kZW5jaWVzXG4gICAgLnRoZW4oXyA9PiBsb2coJ2RlcGVuZGVuY2llcycpKVxuICAgIC50aGVuKF8gPT4gaW5zdGFsbEFsbChjdHgsXG4gICAgICBmdWxsZGF0YS5kZXBlbmRlbmNpZXMsXG4gICAgICBqb2luKHBhdGhzLnRtcCwgJ18nLCAnbm9kZV9tb2R1bGVzJyksXG4gICAgICB7IGtleXBhdGg6IHBrZy5rZXlwYXRoLmNvbmNhdChbIHBrZy5mdWxsbmFtZSBdKSB9KSlcblxuICAgIC8vIHN5bWxpbmsgaXRzZWxmOyAuIC0+IG5vZGVfbW9kdWxlcy9sb2Rhc2hANC4wLjBcbiAgICAvLyB0aGlzIHdheSBpdCBjYW4gcmVxdWlyZSBpdHNlbGZcbiAgICAudGhlbihfID0+IHN5bWxpbmtTZWxmKHBhdGhzLnRtcCwgZnVsbGRhdGEsIHBrZy5rZXlwYXRoLmxlbmd0aCkpXG5cbiAgICAvLyBwb3N0aW5zdGFsbCBob29rc1xuICAgIC50aGVuKF8gPT4gIWN0eC5pZ25vcmVTY3JpcHRzICYmIHBvc3RJbnN0YWxsKHBhdGhzLnRtcCwgZnVsbGRhdGEsIGluc3RhbGxMb2dnZXIobG9nLCBwa2cpKSlcblxuICAgIC8vIG1vdmUgdG8gLnN0b3JlL2xvZGFzaEA0LjAuMDsgcmVtb3ZlIHRoZSBzdHViIGRvbmUgZWFybGllclxuICAgIC50aGVuKF8gPT4gZnMudW5saW5rKGpvaW4ocGF0aHMudG1wLCAnLnBucG1faW5wcm9ncmVzcycpKSlcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHN5bWxpbmtUb01vZHVsZXMgZm9yIGFub3RoZXIgcHJvamVjdCBkZXBlbmRlbnRcbiAgICAvLyBvbiB0aGlzIHBhY2thZ2Ugd2lsbCBub3QgZ2V0IGNhbGxlZCBpbmJldHdlZW4gYHVubGlua2AgYW5kIGByZW5hbWVgXG4gICAgLy8gdGhlIGVhc2llc3Qgd2F5IHRvIGFjaGlldmUgdGhpcyBpcyB0byBtYWtlIHRoZW0gc3luY2hyb25vdXNcbiAgICAudGhlbihfID0+IHtcbiAgICAgIGZzLnVubGlua1N5bmMocGF0aHMudGFyZ2V0KVxuICAgICAgZnMucmVuYW1lU3luYyhwYXRocy50bXAsIHBhdGhzLnRhcmdldClcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTG9nZ2VyIChsb2csIHBrZykge1xuICByZXR1cm4gKHN0cmVhbSwgbGluZSkgPT4ge1xuICAgIHJlcXVpcmUoJ2RlYnVnJykoJ3BucG06cG9zdF9pbnN0YWxsJykoJyVzICVzJywgcGtnLmZ1bGxuYW1lLCBsaW5lKVxuICAgIGxvZyhzdHJlYW0sIHsgbmFtZTogcGtnLmZ1bGxuYW1lLCBsaW5lOiBsaW5lIH0pXG4gIH1cbn1cblxuLypcbiAqIFN5bWxpbmsgYSBwYWNrYWdlIGludG8gaXRzIG93biBub2RlX21vZHVsZXMuIHRoaXMgd2F5LCBiYWJlbC1ydW50aW1lQDUgY2FuXG4gKiByZXF1aXJlKCdiYWJlbC1ydW50aW1lJykgd2l0aGluIGl0c2VsZi5cbiAqL1xuXG5mdW5jdGlvbiBzeW1saW5rU2VsZiAodGFyZ2V0LCBwa2csIGRlcHRoKSB7XG4gIGRlYnVnKCdzeW1saW5rU2VsZiAlcycsIHBrZy5uYW1lKVxuICBpZiAoZGVwdGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWtkaXJwKGpvaW4odGFyZ2V0LCAnbm9kZV9tb2R1bGVzJykpXG4gICAgICAudGhlbihfID0+IHN5bWxpbmsoXG4gICAgICAgIGpvaW4oJy4uJywgJ18nKSxcbiAgICAgICAgam9pbih0YXJnZXQsICdub2RlX21vZHVsZXMnLCBwa2cubmFtZSkpKVxuICB9XG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBmaW5hbCBzeW1saW5raW5nIG9mIC4vLnN0b3JlL3hAMS4wLjAgLT4gLi94LlxuICpcbiAqICAgICB0YXJnZXQgPSAnL25vZGVfbW9kdWxlcy8uc3RvcmUvbG9kYXNoQDQuMC4wJ1xuICogICAgIG1vZHVsZXMgPSAnLi9ub2RlX21vZHVsZXMnXG4gKiAgICAgc3ltbGlua1RvTW9kdWxlcyhmdWxsbmFtZSwgbW9kdWxlcylcbiAqL1xuXG5mdW5jdGlvbiBzeW1saW5rVG9Nb2R1bGVzICh0YXJnZXQsIG1vZHVsZXMpIHtcbiAgLy8gVE9ETzogdW5jb21tZW50IHRvIG1ha2UgdGhpbmdzIGZhaWxcbiAgdmFyIHBrZ0RhdGEgPSByZXF1aXJlSnNvbihqb2luKHRhcmdldCwgJ3BhY2thZ2UuanNvbicpKVxuICBpZiAoIXBrZ0RhdGEubmFtZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFja2FnZS5qc29uIGZvciAnICsgdGFyZ2V0KSB9XG5cbiAgLy8gbG9kYXNoIC0+IC5zdG9yZS9sb2Rhc2hANC4wLjBcbiAgLy8gLnN0b3JlL2Zvb0AxLjAuMC9ub2RlX21vZHVsZXMvbG9kYXNoIC0+IC4uLy4uLy4uLy5zdG9yZS9sb2Rhc2hANC4wLjBcbiAgLy8gLnRtcC8wMTIzNDU2Nzg5MC9ub2RlX21vZHVsZXMvbG9kYXNoIC0+IC4uLy4uLy4uLy5zdG9yZS9sb2Rhc2hANC4wLjBcbiAgdmFyIG91dCA9IGpvaW4obW9kdWxlcywgcGtnRGF0YS5uYW1lKVxuICByZXR1cm4gbWtkaXJwKGRpcm5hbWUob3V0KSlcbiAgICAudGhlbihfID0+IHJlbFN5bWxpbmsodGFyZ2V0LCBvdXQpKVxufVxuXG4vKlxuICogSWYgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsIHJ1biBgZm4oKWAuXG4gKiBJZiBpdCBleGlzdHMgYW5kIGlzIG5vdCBpbiBwcm9ncmVzcywgZG9uJ3QgZG8gYW55dGhpbmcuXG4gKiBJZiBpdCdzIGluIHByb2dyZXNzLCBjaGVjayBpZiB3ZSdyZSB3b3JraW5nIG9uIGl0LiBJZiB3ZSdyZSBub3QsXG4gKiBvYmxpdGVyYXRlIGl0IGFuZCBydW4gYGZuKClgLlxuICovXG5cbmZ1bmN0aW9uIG1ha2UgKHBhdGgsIGlzV29ya2luZywgZm4pIHtcbiAgcmV0dXJuIGZzLnN0YXQocGF0aClcbiAgLnRoZW4oXyA9PiB7XG4gICAgcmV0dXJuIGZzLnN0YXQoam9pbihwYXRoLCAnLnBucG1faW5wcm9ncmVzcycpKVxuICAgIC50aGVuKF8gPT4ge1xuICAgICAgaWYgKCFpc1dvcmtpbmcpIHJldHVybiBvYmxpdGVyYXRlKHBhdGgpLnRoZW4oZm4pXG4gICAgfSlcbiAgICAuY2F0Y2goZXJyID0+IHsgaWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJykgdGhyb3cgZXJyIH0pXG4gIH0pXG4gIC5jYXRjaChlcnIgPT4ge1xuICAgIGlmIChlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIHRocm93IGVyclxuICAgIHJldHVybiBmbigpXG4gIH0pXG59XG5cbi8qXG4gKiBTYXZlIHByb21pc2VzIGZvciBsYXRlclxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemUgKGxvY2tzLCBrZXksIGZuKSB7XG4gIGlmIChsb2NrcyAmJiBsb2Nrc1trZXldKSByZXR1cm4gbG9ja3Nba2V5XVxuICBsb2Nrc1trZXldID0gZm4oKVxuICByZXR1cm4gbG9ja3Nba2V5XVxufVxuIl19